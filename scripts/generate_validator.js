import * as execute from "https://deno.land/x/execute@v1.1.0/mod.ts";

async function main() {
    if (Deno.args[0]) {
        generate(Deno.args[0]);
        return;
    }

    let denoConfigFile;
    try {
        const f = await Deno.readFile("deno.json");
        denoConfigFile = (new TextDecoder()).decode(f);
    } catch (_) {
        throw "missing $1 or ./deno.json";
    }

    const denoConfig = JSON.parse(denoConfigFile);
    if (!denoConfig.generateValidator) {
        throw "deno.json missing .generateValidator";
    }

    for (const name of denoConfig.generateValidator) {
        generate(name);
    }
}

async function generate(sourceFile) {
    const targetFile = sourceFile.split(".").slice(0, -1).join(".") + "_validator.ts";

    const docOutput = await execute.exec(["deno", "doc", "--json", sourceFile]);

    const doc = JSON.parse(docOutput);
    const val = new validator(doc);
    const out = val.generate();

    const file = `
		// Code generated by generate_validator.js. DO NOT EDIT.
		//
		// deno-lint-ignore-file
		import * as t from "./${sourceFile.split("/").at(-1)}";

		// ValidationError is thrown on every error returned by ValidateX
		// functions.
		export class ValidationError extends Error {}

		${out}
	`;

    const tmp = Deno.makeTempFileSync({
        dir: "./",
        prefix: ".~generate_validator-",
        suffix: ".ts",
    });
    Deno.writeTextFileSync(tmp, file);

    try {
        await execute.exec(["deno", "fmt", tmp]);
        Deno.renameSync(tmp, targetFile);
    } catch (err) {
        console.error(err);
        console.log(fileCode);
    }
}

class validator {
    constructor(doc) {
        this.doc = doc;
        this.types = new Map();

        doc.forEach((typ) => {
            this.types.set(typ.name, typ);
        });
    }

    generate() {
        return this.doc
            .filter((typ) => {
                return typ.kind == "typeAlias" && typ.declarationKind == "export";
            })
            .map((typ) => ({
                name: typ.name,
                opts: this._doType(typ),
            }))
            .map((o) => (o.opts == null ? "" : `
				// Validate${o.name} validates the needed type constraints
				// from v and cast it to ${o.name}.
				export function Validate${o.name}(v: any): t.${o.name} {
					${o.opts}
					return v as t.${o.name};
				};
			`))
            .join("\n");
    }

    _doType(tsType) {
        const opts = this._doTypeRec(tsType, "v");
        if (opts.length == 0) return null;

        return `
			${opts.join("\n")}
		`;
    }

    _doTypeRec(tsType, prefix) {
        const opts = [];

        switch (tsType.kind) {
            case "typeRef": {
                // Expensive check to see if we're generating validators for
                // this type. This is doing the work for the same input multiple
                // times, but we can memoize it later.
                const dstType = this.types.get(tsType.typeRef.typeName);
                if (!dstType) {
                    return [];
                }

                if (this._doTypeRec(dstType, prefix).length == 0) {
                    return [];
                }

                return [`Validate${tsType.typeRef.typeName}(${prefix})`];
            }
            case "typeLiteral": {
                const props = tsType.typeLiteral.properties;

                props.forEach((prop) => {
                    const name = dot(prefix, prop.name);

                    const notChecker = (tsType) => {
                        if (!tsType) {
                            return undefined;
                        }
                        switch (tsType.kind) {
                            case "typeRef":
                                return notChecker(this.types.get(tsType.typeRef.typeName));
                            case "literal":
                                switch (tsType.literal.kind) {
                                    case "string":
                                        return `${name} !== "${tsType.literal.string}"`;
                                }
                                break;
                            case "typeLiteral", "array":
                                return `typeof ${name} !== "object"`;
                        }
                        if (tsType.keyword) {
                            return `typeof ${name} !== "${tsType.keyword}"`;
                        }
                        return `${name} === undefined`;
                    };

                    const not = notChecker(prop.tsType);
                    if (!not) {
                        return [];
                    }

                    if (!prop.optional) {
                        opts.push(`if (${not}) throw new ValidationError("missing ${name}");`);
                    }

                    const child = this._doTypeRec(prop.tsType, dot(prefix, prop.name));
                    if (child.length > 0) {
                        if (prop.optional) {
                            opts.push(`if (!(${not})) {`);
                            opts.push(...child);
                            opts.push(`}`);
                        } else {
                            opts.push(...child);
                        }
                    }
                });

                return opts;
            }
            case "union": {
                const types = [];
                tsType.union.forEach((typ) => {
                    switch (typ.kind) {
                        case "typeRef": {
                            if (typ.typeRef.typeParams) {
                                throw "typeParams not supported for union";
                            }

                            const actual = this.types.get(typ.typeRef.typeName);
                            if (!actual) {
                                throw `unknown type alias ${typ.typeRef.typeName}`;
                            }

                            if (actual.kind != "typeAlias") return;
                            if (actual.declarationKind != "export") return;
                            if (actual.typeAliasDef.tsType.kind != "typeLiteral") return;

                            types.push({
                                name: actual.name,
                                tsType: actual.typeAliasDef.tsType,
                            });
                            break;
                        }
                        case "typeLiteral": {
                            types.push({
                                name: null,
                                tsType: typ,
                            });
                            break;
                        }
                    }
                });

                // fields maps name. It should only keep track of properties of
                // type literal.
                const fields = new Map();
                types.forEach(({ name, tsType }) => {
                    // This is not recursive, which is fine. It would be nice,
                    // but we don't need it.
                    const props = tsType.typeLiteral.properties;
                    props.forEach((prop) => {
                        if (prop.tsType.kind != "literal") return;
                        if (prop.tsType.literal.kind != "string") return;

                        const v = {
                            type: name,
                            literal: prop.tsType.literal.string,
                        };

                        let vs = fields.get(prop.name);
                        if (vs) {
                            vs.push(v);
                        } else {
                            vs = [v];
                        }

                        fields.set(prop.name, vs);
                    });
                });

                const unionFields = new Map();
                fields.forEach((vs, name) => {
                    if (vs.length == types.length) {
                        unionFields.set(name, vs);
                    }
                });

                switch (unionFields.size) {
                    case 0:
                        return [];
                    case 1:
                        break;
                    default:
                        throw "more than 1 union fields unsupported";
                }

                const [field] = unionFields.keys();
                const [values] = unionFields.values();

                opts.push(`switch (${dot(prefix, field)}) {`);
                values
                    .filter((v) => !!v.type)
                    .forEach((v) => {
                        opts.push(`case "${v.literal}": {`);
                        opts.push(`  Validate${v.type}(v)`);
                        opts.push(`  break`);
                        opts.push(`}`);
                    });
                opts.push("case undefined: {");
                opts.push(`  throw new ValidationError("missing ${dot(prefix, field)}")`);
                opts.push(`}`);
                opts.push("default: {");
                opts.push(`  throw new ValidationError("unknown ${dot(prefix, field)} given")`);
                opts.push(`}`);
                opts.push("}");

                return opts;
            }
            case "typeAlias": {
                if (tsType.declarationKind == "export") {
                    return this._doTypeRec(tsType.typeAliasDef.tsType, prefix);
                }
                return [];
            }
            default: {
                return [];
            }
        }
    }
}

function dot(...dots) {
    return dots.join(".");
}

await main();
